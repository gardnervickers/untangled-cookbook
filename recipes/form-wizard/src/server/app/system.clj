(ns app.system
  (:require
    [untangled.server.core :as core]
    [app.api :as api]
    [om.next.server :as om]
    [taoensso.timbre :as timbre]
    [com.stuartsierra.component :as comp]
    [clojure.java.jdbc :as jdbc]
    [om.next.impl.parser :as op])
  (:import (clojure.lang IFn)))

; These are just wrappers so you can see incoming server requests
(defn logging-mutate [env k params]
  (timbre/info "Mutation Request: " k)
  (api/apimutate env k params))

(defn logging-query [{:keys [ast] :as env} k params]
  (timbre/info "Query: " (op/ast->expr ast))
  (api/api-read env k params))

; This gets called at startup to ensure our database has schema.
(defn build-schema [db]
  (db (fn [c]
        (jdbc/execute! c [(str "CREATE TABLE IF NOT EXISTS facial_survey ("
                            "id integer generated by default as identity primary key,"
                            "gender varchar(10),"
                            "like_shaving boolean,"
                            "beards_sexy boolean)")]))))

; A Stuart S. component for the SQL database (we're using an in-memory db, but feel free to change the URL)
(defrecord Database [dbspec run-in-transaction]
  ; By implementing this protocol, our database component can act as a function. We do this as
  ; a convenience for running transactions in our API. The database itself will be injected into the
  ; Om env parameter. All we need to do is pull it out and call it like a function. We pass it
  ; an operation, which is a function that gets a connection and returns a result.
  IFn
  (invoke [this operation]
    (jdbc/with-db-connection [conn dbspec]
      (jdbc/with-db-transaction [c conn]
        (operation c))))
  comp/Lifecycle
  (start [this]
    (let [db {:dbtype         "hsqldb"                      ; clojure jdbc database spec
              :connection-uri "jdbc:hsqldb:mem:resultsdb"
              :user           "SA"
              :password       ""}
          rv (assoc this :dbspec db)]
      (build-schema rv)
      rv))
  (stop [this] this))

(defn make-system []
  (core/make-untangled-server
    :config-path "config/recipe.edn"
    :parser (om/parser {:read logging-query :mutate logging-mutate})
    ; This is how our database gets in the system:
    :components {:database (map->Database {})}
    ; this is how the database component ends up in our Om `env`
    :parser-injections #{:database}))
